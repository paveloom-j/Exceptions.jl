var documenterSearchIndex = {"docs":
[{"location":"manual/customization/#Customization","page":"Customization","title":"Customization","text":"","category":"section"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"Let's look at what the @exception macro returns. In a slightly simplistic way, it looks like this:","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"@doc $(docstring)\nmutable struct $(exception_name) <: Exception\n    $(args...)\nend\n\nBase.showerror(io::IO, e::$(exception_name)) =\nprint(io, $(error_message_bits...))","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"All of that gets put in a quote, and variables / expressions with a dollar symbol get interpolated.","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"What are these values equal? Well, args is the second and all the following arguments passed to the main macro; exception_name, docstring, and error_message_bits are arguments of an auxiliary macro created by the main macro.","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"Let's check it out:","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"using Exceptions\n@exception m\n@m MyException \"Docstring\" \"ErrorMessage\"\ntry\n    throw(MyException())\ncatch e\n    showerror(stdout, e)\nend","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"What is that headline, you might ask? For an answer, let's look a little further behind the scenes:","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"args = $(args)\n\nerror_header = \"$(__module__).$(exception_name):\"\nerror_message_bits = (\"\\n\\n$(error_header)\\n\", error_message_bits..., '\\n')\n\n$(context)\n\nreturn esc(\n    quote\n        @doc $(docstring)\n        mutable struct $(exception_name) <: Exception\n            $(args...)\n        end\n\n        Base.showerror(io::IO, e::$(exception_name)) =\n        print(io, $(error_message_bits...))\n    end\n)","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"As you can see, error_message_bits get intentionally modified before the interpolation. That's what might be called the default context. The module in which the macro is invoked and the exception name get specified in the row before the error message. This piece of information gets separated by newlines on both sides.","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"This strange module name appears because these outputs get generated with the documentation. If you run the snippet above in the REPL, the module name will be equal to Main.","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"What's not mentioned about this snippet yet? Ah, yes, the most important thing. See the $(context) interpolation at the top level? That's your ticket to almost unlimited customization. Any variables mentioned may be modified to obtain the desired result.","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"All one has to do is to pass the context keyword with a block of code when using the main macro. Like this:","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"@exception m context = begin\n    error_message_bits = error_message_bits[2:end-1]\nend","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"With this snippet, we canceled the default changes for the error message. This gives us the following:","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"@m MyException2 \"Docstring\" \"What can I say except you're welcome\"\ntry\n    throw(MyException2())\ncatch e\n    showerror(stdout, e)\nend","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"Note that it is the code block (begin end) that should be passed as the context, not the quote (quote end) or the expression (:()).","category":"page"},{"location":"manual/customization/","page":"Customization","title":"Customization","text":"Further, it all depends only on your goals and imagination. See also the macro's documentation string (@exception) for a full picture of what's going on behind the scenes and what you can influence. You can also see the real use of this macro in the code of the PDFHighlights.jl package.","category":"page"},{"location":"lib/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"lib/internals/#Modules","page":"Internals","title":"Modules","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Exceptions\nExceptions.Internal","category":"page"},{"location":"lib/internals/#Exceptions","page":"Internals","title":"Exceptions","text":"A package for the quick creation of customizable exceptions.\n\nLinks:\n\nRepo: https://github.com/paveloom-j/Exceptions.jl\nDocs: https://paveloom-j.github.io/Exceptions.jl\n\n\n\n\n\n","category":"module"},{"location":"lib/internals/#Exceptions.Internal","page":"Internals","title":"Exceptions.Internal","text":"This module contains all inner parts of this package.\n\n\n\n\n\n","category":"module"},{"location":"lib/internals/#Constants","page":"Internals","title":"Constants","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [Exceptions.Internal]\nOrder = [:constant]","category":"page"},{"location":"lib/internals/#Exceptions.Internal.EXCEPTIONS","page":"Internals","title":"Exceptions.Internal.EXCEPTIONS","text":"A dictionary (Symbol => Any) containing all exceptions used in this package.\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [Exceptions.Internal]\nOrder = [:type]","category":"page"},{"location":"lib/internals/#Exceptions.Internal.DocstringIsNotAString","page":"Internals","title":"Exceptions.Internal.DocstringIsNotAString","text":"Exception thrown when the passed expression for docstring does not yield a string.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#Exceptions.Internal.ErrorMessageIsNotAString","page":"Internals","title":"Exceptions.Internal.ErrorMessageIsNotAString","text":"Exception thrown when the passed expression(s) for error message (do)es not yield a string.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#Exceptions.Internal.FieldsOnly","page":"Internals","title":"Exceptions.Internal.FieldsOnly","text":"Exception thrown when the passed argument is not a structure field.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#Exceptions.Internal.OnlyOneEquation","page":"Internals","title":"Exceptions.Internal.OnlyOneEquation","text":"Exception thrown when a non-context equation has been passed.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#Macros","page":"Internals","title":"Macros","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [Exceptions.Internal]\nOrder = [:macro]","category":"page"},{"location":"lib/internals/#Exceptions.Internal.@aux-Tuple{Symbol,Union{Expr, String},Vararg{Union{Expr, String},N} where N}","page":"Internals","title":"Exceptions.Internal.@aux","text":"@aux(\n    exception_name::Symbol,\n    docstring::Union{Expr, String},\n    error_message_bits::Tuple{Vararg{Union{Expr, String}}},\n) -> Expr\n\nCreate an exception with no fields and push it to the exceptions dictionary.\n\nArguments\n\nexception_name::Symbol: name of the exception\ndocstring::Union{Expr, String}: documentation string\nerror_message_bits::Tuple{Vararg{Union{Expr, String}}}: strings and expressions which will be interpolated in the showerror output\n\nReturns\n\nExpr: an exception definition (struct + showerror overload)\n\nSee also: @exception\n\n\n\n\n\n","category":"macro"},{"location":"lib/internals/#Exceptions.Internal.@exception-Tuple{Symbol,Vararg{Union{Expr, Symbol},N} where N}","page":"Internals","title":"Exceptions.Internal.@exception","text":"@exception(macro_name::Symbol, args::Union{Symbol, Expr}...; context::Expr=:()) -> Expr\n\nCreate a macro to create exceptions. Optionally inject context before defining the structure.\n\nArguments\n\nmacro_name::Symbol: name of the macro\nargs::Tuple{Vararg{Union{Symbol, Expr}}}: a set of fields to be defined in the exception structure\n\nKeywords\n\ncontext::Expr=:(): expression evaluated before defining the exception structure\n\nReturns\n\nExpr: new macro definition\n\nThrows\n\nOnlyOneEquation: more than one equation has been passed\n\nExample\n\nusing Exceptions\nusing Suppressor\nusing SyntaxTree\n\nmacro_name = :name\nargs = (:(arg1::String), :(arg2))\ncontext = :()\n\nEXCEPTIONS = Dict{Symbol, Any}()\nEXCEPTIONS[:DocstringIsNotAString] = Exceptions.Internal.DocstringIsNotAString\nEXCEPTIONS[:ErrorMessageIsNotAString] = Exceptions.Internal.ErrorMessageIsNotAString\n\nd1 = @capture_out(\n    @macroexpand(@exception(name, arg1::String, arg2)) |> linefilter! |> dump\n)\n\nd2 = @capture_out quote\n    macro $(macro_name)(\n        exception_name::Symbol,\n        docstring::Union{Expr, String},\n        error_message_bits::Union{Expr, String, Char}...,\n    )\n        args = $(args)\n\n        error_header = \"$(__module__).$(exception_name):\"\n        error_message_bits = (\"\\n\\n$(error_header)\\n\", error_message_bits..., '\\n')\n\n        $(context)\n\n        EX = $(EXCEPTIONS)\n        error_message_bits_filtered = filter(\n            e -> typeof(e) == String || e.head ≠ :(.) && e.args[1] ≠ :(e),\n            error_message_bits,\n        )\n\n        return esc(\n            quote\n                # Checks\n                if !($(docstring) isa String)\n                    throw($(EX[:DocstringIsNotAString])())\n                end\n                if !(string($(error_message_bits_filtered...)) isa String)\n                    throw($(EX[:ErrorMessageIsNotAString])())\n                end\n\n                @doc $(docstring)\n                mutable struct $(exception_name) <: Exception\n                    $(args...)\n                end\n\n                Base.showerror(io::IO, e::$(exception_name)) =\n                print(io, $(error_message_bits...))\n            end\n        )\n    end\nend |> linefilter! |> dump\n\nd1 == d2\n\n\n\n\n\n","category":"macro"},{"location":"lib/#Package-Index","page":"Index","title":"Package Index","text":"","category":"section"},{"location":"lib/","page":"Index","title":"Index","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"manual/guide/#Package-Guide","page":"Guide","title":"Package Guide","text":"","category":"section"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"This package is designed for both beginners who are not sure how to create an exception and Julia power users who are tired of copying snippets of code containing structure definition and overloading the showerror function.","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"It is assumed to be used by developers inside their packages, but the proposed macro should be usable everywhere.","category":"page"},{"location":"manual/guide/#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"The package is available in the General registry, so the installation process is quite simple: from the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"pkg> add Exceptions","category":"page"},{"location":"manual/guide/#Creating-an-exception","page":"Guide","title":"Creating an exception","text":"","category":"section"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"To create a new exception means to create a new data type that is a subtype of Exception. In the simple case, it looks like this:","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"mutable struct Name <: Exception\nend","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"You can throw such an exception immediately after creation, but the error message will not be very informative:","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"try\n  throw(Name())\ncatch e\n  showerror(stdout, e)\nend","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"However, it's pretty easy to fix. As shown in the example, the error message is displayed by the showerror function, which means we can overload this function for our type:","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"Base.showerror(io::IO, e::Name) = print(io, \"I'm gonna thrill you tonight\")","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"Now let's check it out:","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"try\n  throw(Name())\ncatch e\n  showerror(stdout, e)\nend","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"Okay, it's better. But what if we want to pass arguments to an exception when thrown? Not a problem, additional arguments can be specified inside the type definition. The corresponding constructor is created automatically:","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"mutable struct Name <: Exception\n    name::String\nend\n\nBase.showerror(io::IO, e::Name) = print(io, \"I'm gonna thrill you tonight, \", e.name)\n\ntry\n  throw(Name(\"Michael\"))\ncatch e\n  showerror(stdout, e)\nend","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"Okay, it's not that hard. But wait, what if you need to create twenty such exceptions? What if each of them should have a docstring with the same header and a description of fields depending on the number of arguments the exception has? That's where the macro provided by this package may be useful.","category":"page"},{"location":"manual/guide/#UsingMacro","page":"Guide","title":"Using macro","text":"","category":"section"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"When creating an exception set, you may encounter the fact that you need to define several similar exceptions that have the same number of arguments but differ only by names.","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"For example, imagine the situation that you need to create five exceptions that don't accept any arguments. For starters, we will create an auxiliary macro:","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"using Exceptions\n@exception no_args","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"What's happened now? You have now created a helper macro that accepts as arguments a name, a documentation string, and a set of chars, strings, and expressions for the error message.","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"You can now create an exception like this:","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"@no_args e1 \"Docstring\" \"ErrorMessage\"","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"Yes, one line for the simplest case. Actually, let's do a few more.","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"@no_args e2 \"Doc\" * \"string\" \"And though \" \"you fight \" \"to stay alive\"\n@no_args e3 string(\"Doc\", \"string\") string(\"Your body \", \"starts to shiver\")\n@no_args e4 sprint(print, \"Docstring\") join([\"For no mere mortal\", \"can resist\"], ' ')\n@no_args e5 replace(\"Doc\", \"Doc\" => \"Docstring\") (\"The evil \", \"of the thriller\")...","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"As you can see, the second argument can be both a string and an exception. In doing so, both it and the third argument must yield a string. The first argument can only be a string.","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"Let's look at this stanza:","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"for e in [e2, e3, e4, e5]\n    try\n        throw(e())\n    catch e\n        showerror(stdout, e)\n    end\nend","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"Okay, how about some arguments?","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"@exception one_arg name::String\n@exception two_args name number::Int\n\n@one_arg e6 \"Docstring\" \"Gimme the cash, \" e.name \"!\"\n@two_args e7 \"Docstring\" \"Is that a \" e.name \"-\" e.number \"? A very dangerous gun.\"\n\nfor e in [e6 => (\"Korben\",), e7 => (\"Z\", 140)]\n    try\n        throw(e.first(e.second...))\n    catch e\n        showerror(stdout, e)\n    end\nend","category":"page"},{"location":"manual/guide/","page":"Guide","title":"Guide","text":"By this point, you're probably already interested in these headlines before the error messages (perhaps, in how to get rid of them). See more about this on the Customization page.","category":"page"},{"location":"lib/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"It's the one and only, the @exception macro. That's right, all the magic with one macro.","category":"page"},{"location":"#Exceptions.jl","page":"Home","title":"Exceptions.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Easy exception creation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"\n<table style=\"width: fit-content; border-collapse: collapse;\">\n  <tbody>\n    <tr>\n      <th style=\"text-align: center; border: 1px solid lightgray; padding: 6px 12px;\">\n        Code Coverage\n      </th>\n\n      <th style=\"text-align: center; border: 1px solid lightgray; padding: 6px 12px;\">\n        Repository & License\n      </th>\n\n      <th style=\"text-align: center; border: 1px solid lightgray; padding: 6px 12px;\">\n        Playground\n      </th>\n    </tr>\n    <tr>\n      <td style=\"text-align: center; border: 1px solid lightgray; padding: 6px 12px;\">\n        <a href=\"https://codecov.io/gh/paveloom-j/Exceptions.jl\" style=\"position: relative; bottom: -2px;\">\n          <img src=\"https://codecov.io/gh/paveloom-j/Exceptions.jl/branch/master/graph/badge.svg\" />\n        </a>\n      </td>\n\n      <td style=\"text-align: center; border: 1px solid lightgray; padding: 6px 12px;\">\n        <a href=\"https://github.com/paveloom-j/Exceptions.jl\" style=\"position: relative; bottom: -2px;\">\n          <img src=\"https://img.shields.io/badge/GitHub-paveloom--j%2FExceptions.jl-5DA399.svg\">\n        </a>\n        <a href=\"https://github.com/paveloom-j/Exceptions.jl/blob/master/LICENSE.md\" style=\"position: relative; bottom: -2px;\">\n          <img src=\"https://img.shields.io/badge/license-MIT-5DA399.svg\">\n        </a>\n      </td>\n\n      <td style=\"text-align: center; border: 1px solid lightgray; padding: 6px 12px;\">\n        <a href=\"https://mybinder.org/v2/gh/paveloom-j/Exceptions.jl/master?urlpath=lab/tree/playground.ipynb\" style=\"position: relative; bottom: -2px;\">\n          <img src=\"https://mybinder.org/badge_logo.svg\">\n        </a>\n      </td>\n    </tr>\n  </tbody>\n</table>\n","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for the quick creation of customizable exceptions.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Create exceptions with simple macro calls\nCustomize any bits of exceptions to your liking","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(\n    s -> \"manual/$(s)\",\n    [\"guide.md\", \"customization.md\"],\n)","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(\n    s -> \"lib/$(s)\",\n    [\"index.md\", \"public.md\", \"internals.md\"],\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Logo from icons8.com.","category":"page"}]
}
