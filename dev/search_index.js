var documenterSearchIndex = {"docs":
[{"location":"lib/internals/#Internal","page":"Internals","title":"Internal","text":"","category":"section"},{"location":"lib/internals/#Modules","page":"Internals","title":"Modules","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Exceptions\nExceptions.Internal","category":"page"},{"location":"lib/internals/#Exceptions","page":"Internals","title":"Exceptions","text":"f\n\n\n\n\n\n","category":"module"},{"location":"lib/internals/#Exceptions.Internal","page":"Internals","title":"Exceptions.Internal","text":"f\n\n\n\n\n\n","category":"module"},{"location":"lib/internals/#Constants","page":"Internals","title":"Constants","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [Exceptions.Internal]\nOrder = [:constant]","category":"page"},{"location":"lib/internals/#Types","page":"Internals","title":"Types","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [Exceptions.Internal]\nOrder = [:type]","category":"page"},{"location":"lib/internals/#Exceptions.Internal.DocstringIsNotAString","page":"Internals","title":"Exceptions.Internal.DocstringIsNotAString","text":"Exception thrown when the passed expression for docstring does not yield a string.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#Exceptions.Internal.ErrorMessageIsNotAString","page":"Internals","title":"Exceptions.Internal.ErrorMessageIsNotAString","text":"Exception thrown when the passed expression(s) for error message (do)es not yield a string.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#Exceptions.Internal.OnlyOneContext","page":"Internals","title":"Exceptions.Internal.OnlyOneContext","text":"Exception thrown when more than one context has been passed.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#Exceptions.Internal.OnlyOneEquation","page":"Internals","title":"Exceptions.Internal.OnlyOneEquation","text":"Exception thrown when non-context equation has been passed.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#Macros","page":"Internals","title":"Macros","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [Exceptions.Internal]\nOrder = [:macro]","category":"page"},{"location":"lib/internals/#Exceptions.Internal.@exception-Tuple{Symbol,Vararg{Expr,N} where N}","page":"Internals","title":"Exceptions.Internal.@exception","text":"@exception(macro_name::Symbol, args::Expr...; context::Expr=:()) -> Expr\n\nCreate a macro to create exceptions. Optionally inject context before defining the structure.\n\nArguments\n\nmacro_name::Symbol: name of the macro\nargs::Tuple{Vararg{Expr}}: a set of fields to be defined in the exception structure\n\nKeywords\n\ncontext::Expr=:(): expression evaluated before defining the exception structure\n\nReturns\n\nExpr: new macro definition\n\nThrows\n\nOnlyOneContext: more than one context has been passed\nOnlyOneEquation: more than one equation has been passed\n\nExample\n\nusing Exceptions\nusing Suppressor\nusing SyntaxTree\n\nmacro_name = :name\nargs = (:(arg1::String), :(arg2::Int))\ncontext = :()\n\nexceptions = Dict{Symbol, Any}()\nexceptions[:DocstringIsNotAString] = Exceptions.Internal.DocstringIsNotAString\nexceptions[:ErrorMessageIsNotAString] = Exceptions.Internal.ErrorMessageIsNotAString\n\nd1 = @capture_out @macroexpand(@exception(name, arg1::String, arg2::Int)) |>\n     linefilter! |> dump\n\nd2 = @capture_out quote\n    macro $(macro_name)(\n        exception_name::Symbol,\n        docstring::Union{Expr, String},\n        error_message_bits::Union{Expr, String}...,\n    )\n        args = $(args)\n\n        # Defaults\n        module_name = __module__\n        error_header = \"$(module_name).$(exception_name):\"\n\n        $(context)\n\n        e = $(exceptions)\n\n        return esc(\n            quote\n                # Checks\n                if !($(docstring) isa String)\n                    throw($(e[:DocstringIsNotAString])())\n                end\n                if !($(error_message_bits...) isa String)\n                    throw($(e[:ErrorMessageIsNotAString])())\n                end\n\n                @doc $(docstring)\n                mutable struct $(exception_name) <: Exception\n                    $(args...)\n                    $(exception_name)($(args...)) = new($(args...))\n                end\n\n                Base.showerror(io::IO, e::$(module_name).$(exception_name)) =\n                print(\n                    io, string(\n                        '\\n', '\\n',\n                        $(error_header), '\\n',\n                        $(error_message_bits...), '\\n',\n                    )\n                )\n            end\n        )\n    end\nend |> linefilter! |> dump\n\nd1 == d2\n\n\n\n\n\n","category":"macro"},{"location":"lib/#Package-Index","page":"Index","title":"Package Index","text":"","category":"section"},{"location":"lib/#Internal","page":"Index","title":"Internal","text":"","category":"section"},{"location":"lib/","page":"Index","title":"Index","text":"Pages = [\"internals.md\"]","category":"page"},{"location":"lib/public/#Public-Interface","page":"Public","title":"Public Interface","text":"","category":"section"},{"location":"#Exceptions.jl","page":"Home","title":"Exceptions.jl","text":"","category":"section"}]
}
